#!/usr/bin/env python

"""A bot that acts as a manager for Yahoo! fantasy team

Usage:
    ybot [options] <cfg_file>

  <cfg_file>  The name of the configuration file.  See sample_config.ini for
              the format.

Options:
  -a, --apply         Will apply the roster change in Yahoo.  Omitting this
                      assumes a dry run of the roster change.
  -y, --assumeyes     Answer yes for all of the roster moves.                    
  -f, --full          Does a full analysis of the entire lineup meaning all
                      players will be evaluated in an optimized lineup.  This
                      can potentially add a lot of churn to your lineup.  The
                      alternative is to just consider optimizing the open slots
                      in the lineup and the bench.
    -g, --generations=x Number of generations to do during lineup optimization.
                      The more generations, the more combinations of lineups we
                      will evaluate.
    -r, --resetcache    Remove any cache files before starting program.  This is
                      necessary if you changed the source of prediction stats in
                      the config file.
  -i, --ignorestatus  When constructing the lineup, ignore status other than IL.
                      This will allow the bot to pick players that are DTD/NA
                      for the starting lineup.
    --score             Run the scoring script (`scripts/rank_players.py`) before
                                            running the bot and make scored CSV available to the bot.
    --rank-extra=<opts> Quoted options to pass to `scripts/rank_players.py`.
    --input=<path>       Path to a single QuantHockey .xlsx file (overrides data discovery).
    --sheet=<name>       Sheet name in the Excel file to read (default: QuantHockey).
    --projected-games=<n>
                        Projected games to use for per-game scaling (e.g. 82).
    --k=<k>              Shrinkage prior weight for empirical-Bayes (default: 20).
    --decay=<d>         Decay factor to pass to scoring (float between 0 and 1).
    --sort-by=<s>       How to sort input files for scoring: name|mtime.
    --reverse           Reverse the discovered file order.
    --goalie-method=<m> Goalies scoring method: stats|gp-fallback|constant. Overrides scoring default when --score is used.
    --no-per-game       Disable per-game computation in scoring; useful when you want raw totals only.
    --weight-by-games   Weight per-file contributions by games played (default behavior in rank_players).
    --no-weight-by-games
                        Do not weight per-file contributions by games played.
    --normalize-file-weights
                        Normalize per-file weights per-player so no single file dominates.
    --yahoo-points-field=<f>
                        Yahoo points field key to prefer when fetching Yahoo points (e.g. PPT).
    --fuzzy-match=<n>   Enable fuzzy name matching threshold (0-100) when merging Yahoo points.
    --fetch-yahoo       Attempt to fetch Yahoo points via API (requires --league-id and oauth file).
    --league-id=<id>    Yahoo league id to use when fetching Yahoo points.
    --oauth-file=<path> OAuth file path for Yahoo API (default: oauth2.json).

"""
from docopt import docopt
from yahoo_fantasy_bot import automation, oauth2_logger
import logging
import os
import pandas as pd
import configparser
import subprocess
import shlex


pd.options.mode.chained_assignment = None  # default='warn'


if __name__ == '__main__':
    args = docopt(__doc__, version='1.0')

    cfg = configparser.RawConfigParser(
        converters={'list': lambda x: [i.strip() for i in x.split(',')]}
    )
    if not os.path.exists(args['<cfg_file>']):
        raise RuntimeError("Config file does not exist: " + args['<cfg_file>'])
    cfg.read(args['<cfg_file>'])
    if args['--generations'] is not None:
        cfg['LineupOptimizer']['generations'] = args['--generations']

    log_dir = os.path.dirname(cfg['Logger']['file'])
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    oauth2_logger.cleanup()

    logging.basicConfig(
        filename=cfg['Logger']['file'],
        filemode="w",
        level=cfg['Logger']['level'],
        format='%(asctime)s.%(msecs)03d %(module)s-%(funcName)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    auto = automation.Driver(cfg, not args['--apply'], args['--full'],
                             not args['--assumeyes'], args['--resetcache'],
                             args['--ignorestatus'])
    # Optionally run the scoring script and expose the scored CSV to the bot
    if args.get('--score'):
        # default output
        out_path = 'scored_players.csv'

        # Build argument list for rank_players.py. Prefer explicit flags.
        cmd_parts = [os.environ.get('PYTHON', 'python'), 'scripts/rank_players.py', '--out', out_path]

        # Map our new first-class options to rank_players flags
        if args.get('--goalie-method'):
            cmd_parts += ['--goalie-method', args.get('--goalie-method')]
        if args.get('--sort-by'):
            cmd_parts += ['--sort-by', args.get('--sort-by')]
        if args.get('--reverse'):
            cmd_parts += ['--reverse']
        if args.get('--decay'):
            cmd_parts += ['--decay', args.get('--decay')]
        if args.get('--no-per-game'):
            cmd_parts += ['--no-per-game']

            # Extra params to append to the rank_players invocation
            score_opts = args.get('--rank-extra') or ''
            if score_opts:
                # Split and extend
                cmd_parts += shlex.split(score_opts)

            print('Running scoring command:', ' '.join(cmd_parts))
            try:
                proc = subprocess.run(cmd_parts, check=True, capture_output=True)
                print(proc.stdout.decode())
                cfg['Scoring'] = cfg.get('Scoring', {})
                cfg['Scoring']['scored_csv'] = out_path
            except subprocess.CalledProcessError as e:
                print('Scoring command failed:')
                print(e.stdout.decode())
                print(e.stderr.decode())
    auto.run()
